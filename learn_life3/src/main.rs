//1、结构体中的生命周期
#[derive(Debug)]
struct A<'a> {
    name: &'a str,
}

fn main() {
    let n = String::from("hello");
    let a = A{name: &n};
    println!("a = {:#?}", a);

    println!("Hello, world!");
    let s = get_a_str(&n);
    println!("s = {}", s);
}

//2、生命周期省略
fn get_a_str(s: &str) -> &str {
    s
}
//（1）没有生命周期注解却能够编译，原因：早期的rust中必须显式的声明生命周期，后来rust团队将很明确的模式进行了注解的简化。
//（2）遵守生命周期省略规则的情况下能明确变量的声明周期，则无需明确指定生命周期。函数或者方法的参数的生命周期称为输入生命周期，而返回值的生命周期称为输出生命周期。
//（3）编译器采用三条规则判断引用何时不需要生命周期注解，当编译器检查完这三条规则后仍然不能计算出引用的生命周期，则会停止并生成错误。
//（4）生命周期注解省略规则适用于fn定义以及impl块定义，如下：
//   a、每个引用的参数都有它自己的生命周期参数。例如如下：
//          一个引用参数的函数，其中有一个生命周期： fn foo<'a>(x: &'a i32)
//         两个引用参数的函数，则有两个生命周期 ：fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
//         以此类推。
//    b、如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：
//          fn foo(x: &i32) -> &i32   等价于  fn foo<'a>(x: &'a i32) -> &'a i32
//    c、如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为&self或者&mut self，那么self的生命周期被赋予所有输出生命周期参数。例子在下面来看。
//    fn function(&self, x: &str, y: &str, ....) -> &str 
